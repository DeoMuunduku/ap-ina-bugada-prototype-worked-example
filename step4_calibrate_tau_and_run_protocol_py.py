# -*- coding: utf-8 -*-
"""step4_calibrate_tau_and_run_protocol.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15ZSD-IHirkzs8h6IwF07NzqWNaGz0Jx9
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Étape 4 — Calibration τ + exécution du protocole (BMO)

- Lit les splits BMO : episodes_dev(.clean).jsonl, episodes_holdoutH(.clean).jsonl
- Calcule un score p_top (proxy déterministe, anti-leakage)
- Sweep τ sur DEV et H : abstention_rate et coverage_on_labeled
- Choisit τ* pour viser une abstention cible sur DEV (par ex. 20 %)
- Relance le protocole avec τ* sur DEV et H :
  -> eligibility_audit.csv
  -> figures (distribution décisions, p_top, latence)
  -> traces/ et prov/

Adapte seulement les chemins si besoin.
"""

import os
import json
import csv
import math
from collections import Counter

# ==================== CONFIG ====================

# Chemins d'entrée (on préfère *.clean.jsonl s'ils existent)
DEV_CANDIDATES = [
    "/content/drive/MyDrive/splits_bmo/episodes_dev.clean.jsonl",
    "/content/drive/MyDrive/splits_bmo/episodes_dev.jsonl",
]

H_CANDIDATES = [
    "/content/drive/MyDrive/splits_bmo/episodes_holdoutH.clean.jsonl",
    "/content/drive/MyDrive/splits_bmo/episodes_holdoutH.jsonl",
]

# Dossiers de sortie
SWEEP_DIR = "/content/drive/MyDrive/sweep_bmo"
OUT_DEV   = "/content/drive/MyDrive/protocol_bmo_dev"
OUT_H     = "/content/drive/MyDrive/protocol_bmo_H"

# Cible d'abstention (20 %)
TARGET_ABST = 0.20

# Labels d'incidents (ceux qu'on considère "intéressants")
I_IDS = {
    "i:release_regression",
    "i:infra_instability",
    "i:security_threat",
    "i:minor_degradation",
    "i:insufficient_info",
    "i:false_positive",
    "i:business_side_effect",
}

# =================================================

def first_existing(paths):
    for p in paths:
        if os.path.exists(p):
            return p
    return paths[0]

def ensure_dir(p):
    os.makedirs(p, exist_ok=True)

def load_jsonl(path):
    items = []
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                items.append(json.loads(line))
            except Exception:
                continue
    return items

# ---- proxy p_top (déterministe, anti-leakage) ----

def sigmoid(x):
    try:
        return 1.0 / (1.0 + math.exp(-x))
    except OverflowError:
        return 0.0 if x < 0 else 1.0

def infer_p_top(card):
    """
    Score de confiance p_top basé uniquement sur :
      - summary_len
      - text_len
      - severity
    Pas de status ni de résolution -> pas de fuite.
    """
    s_len = int(card.get("summary_len", 0) or 0)
    t_len = int(card.get("text_len", 0) or 0)
    sev   = (card.get("severity") or "unknown").lower()

    sev_bias = {"high": 0.6, "medium": 0.35, "low": 0.15}.get(sev, 0.25)

    x = 0.02 * min(s_len, 200) + 0.005 * min(t_len, 1200) + sev_bias

    # léger jitter déterministe par clé (pour ne pas avoir tous les mêmes)
    k = str(card.get("key") or card.get("ticket_id") or "")
    jitter = (hash(k) % 1000) / 1000.0  # [0, 1)
    x = x + 0.10 * (jitter - 0.5)

    return max(0.0, min(1.0, sigmoid(x)))

# ---- figures (matplotlib, sans style/couleurs forcés) ----

def _mpl():
    import matplotlib
    matplotlib.use("Agg")
    import matplotlib.pyplot as plt
    return plt

def fig_abstention_vs_tau(taus, abst, title, out_png):
    plt = _mpl()
    plt.figure(figsize=(8,4))
    plt.plot(taus, abst, marker="o")
    plt.xlabel("tau")
    plt.ylabel("abstention_rate")
    plt.title(title)
    plt.tight_layout()
    plt.savefig(out_png, dpi=160)
    plt.close()

def fig_coverage_vs_tau(taus, cov, title, out_png):
    plt = _mpl()
    plt.figure(figsize=(8,4))
    plt.plot(taus, cov, marker="o")
    plt.xlabel("tau")
    plt.ylabel("coverage_on_labeled")
    plt.title(title)
    plt.tight_layout()
    plt.savefig(out_png, dpi=160)
    plt.close()

def fig_decision_distribution(accepted_mask, out_png):
    plt = _mpl()
    acc = sum(1 for a in accepted_mask if a)
    abst = len(accepted_mask) - acc
    plt.figure(figsize=(6,4))
    plt.bar(["accepted", "abstain"], [acc, abst])
    plt.title("Decision distribution")
    plt.tight_layout()
    plt.savefig(out_png, dpi=160)
    plt.close()

def fig_p_top_hist_all(p_tops, out_png):
    plt = _mpl()
    plt.figure(figsize=(8,4.5))
    plt.hist(p_tops, bins=30)
    plt.xlabel("p_top")
    plt.ylabel("count")
    plt.title("p_top (all)")
    plt.tight_layout()
    plt.savefig(out_png, dpi=160)
    plt.close()

def fig_p_top_hist_accepted(p_tops, accepted_mask, out_png):
    vals = [v for v,a in zip(p_tops, accepted_mask) if a]
    plt = _mpl()
    plt.figure(figsize=(8,4.5))
    plt.hist(vals, bins=30)
    plt.xlabel("p_top (accepted)")
    plt.ylabel("count")
    plt.title("p_top (accepted only)")
    plt.tight_layout()
    plt.savefig(out_png, dpi=160)
    plt.close()

def fig_latency_hist(latencies_ms, out_png):
    plt = _mpl()
    plt.figure(figsize=(8,4.5))
    plt.hist(latencies_ms, bins=30)
    plt.xlabel("latency (ms)")
    plt.ylabel("count")
    plt.title("Latency histogram")
    plt.tight_layout()
    plt.savefig(out_png, dpi=160)
    plt.close()

# ---- métriques pour un τ donné ----

def metrics_for_tau(cards, tau):
    """
    Retourne:
      - abstention_rate_all
      - coverage_on_labeled (sur les cartes avec silver_label dans I_IDS)
    """
    accepted_flags = []
    labeled_flags = []
    accepted_and_labeled = []

    for c in cards:
        p = infer_p_top(c)
        accept = (p >= (1.0 - tau))
        accepted_flags.append(accept)

        lab = c.get("_silver_label") or "NONE"
        is_labeled = lab in I_IDS

        labeled_flags.append(is_labeled)
        accepted_and_labeled.append(accept and is_labeled)

    n = len(cards)
    abst_all = 1.0 - (sum(1 for a in accepted_flags if a) / n) if n else 0.0

    n_labeled = sum(1 for x in labeled_flags if x)
    cov = (sum(1 for x in accepted_and_labeled if x) / n_labeled) if n_labeled else 0.0

    return abst_all, cov

# ---- sweep τ ----

def sweep_tau(cards, label, out_dir):
    ensure_dir(out_dir)
    taus = [i / 200.0 for i in range(0, 101)]  # 0.00 -> 0.50
    abst_list = []
    cov_list = []

    csv_path = os.path.join(out_dir, f"sweep_{label}.csv")
    with open(csv_path, "w", newline="", encoding="utf-8") as fw:
        cw = csv.writer(fw)
        cw.writerow(["tau", "abstention_rate_all", "coverage_on_labeled"])

        for t in taus:
            abst, cov = metrics_for_tau(cards, t)
            abst_list.append(abst)
            cov_list.append(cov)
            cw.writerow([f"{t:.4f}", f"{abst:.4f}", f"{cov:.4f}"])

    # Figures
    fig_abstention_vs_tau(
        taus, abst_list,
        f"Abstention vs tau ({label})",
        os.path.join(out_dir, f"fig_abstention_vs_tau_{label}.png"),
    )
    fig_coverage_vs_tau(
        taus, cov_list,
        f"Coverage-on-labeled vs tau ({label})",
        os.path.join(out_dir, f"fig_coverage_vs_tau_{label}.png"),
    )

    return taus, abst_list, cov_list

# ---- exécution protocole pour un τ donné ----

def run_protocol(cards, tau, out_dir):
    ensure_dir(out_dir)
    os.makedirs(os.path.join(out_dir, "traces"), exist_ok=True)
    os.makedirs(os.path.join(out_dir, "prov"), exist_ok=True)

    audit_csv = os.path.join(out_dir, "eligibility_audit.csv")

    p_tops = []
    accepted_mask = []
    latencies = []

    with open(audit_csv, "w", newline="", encoding="utf-8") as fw:
        cw = csv.writer(fw)
        cw.writerow(["episode_id", "p_top", "decision", "accepted"])

        for c in cards:
            p = infer_p_top(c)
            accept = (p >= (1.0 - tau))

            # Latence proxy (en ms) : fonction de text_len + petit bruit
            lat = 10.0 + 0.02 * (int(c.get("text_len", 0) or 0)) + (
                hash(str(c.get("key", ""))) % 7
            )

            p_tops.append(p)
            accepted_mask.append(accept)
            latencies.append(lat)

            eid = str(c.get("key") or c.get("ticket_id") or "")
            cw.writerow([eid, f"{p:.4f}", "accept" if accept else "abstain", int(accept)])

            trace = {
                "episode_id": eid,
                "features": {
                    "summary_len": int(c.get("summary_len", 0) or 0),
                    "text_len": int(c.get("text_len", 0) or 0),
                    "severity": c.get("severity") or "unknown",
                },
                "p_top": p,
                "tau": tau,
                "decision": "accept" if accept else "abstain",
            }
            prov = {
                "episode_id": eid,
                "generated_by": "step4_bmo",
                "inputs": {},
                "params": {"tau": tau},
            }

            with open(os.path.join(out_dir, "traces", f"{eid}.json"), "w", encoding="utf-8") as ft:
                json.dump(trace, ft, ensure_ascii=False, indent=2)
            with open(os.path.join(out_dir, "prov", f"{eid}.json"), "w", encoding="utf-8") as fp:
                json.dump(prov, fp, ensure_ascii=False, indent=2)

    abst = 1.0 - (sum(1 for a in accepted_mask if a) / len(accepted_mask))
    print(f"[RUN] episodes: {len(cards)}")
    print(f"[RUN] abstention_rate: {abst:.4f}")
    print(f"- OUT_DIR: {out_dir}")
    print("- eligibility_audit.csv prêt")

    # Figures
    fig_decision_distribution(accepted_mask, os.path.join(out_dir, "fig_decision_distribution.png"))
    fig_p_top_hist_all(p_tops, os.path.join(out_dir, "fig_p_top_hist_all.png"))
    fig_p_top_hist_accepted(p_tops, accepted_mask, os.path.join(out_dir, "fig_p_top_hist_accepted.png"))
    fig_latency_hist(latencies, os.path.join(out_dir, "fig_latency_hist.png"))

    print(f"[RUN] traces: {len(cards)}")
    print(f"[RUN] prov: {len(cards)}")

# ---- main ----

def main():
    dev_path = first_existing(DEV_CANDIDATES)
    h_path   = first_existing(H_CANDIDATES)

    dev_cards = load_jsonl(dev_path)
    h_cards   = load_jsonl(h_path)

    print(f"[LOAD] DEV: {len(dev_cards)} episodes")
    print(f"[LOAD] H  : {len(h_cards)} episodes")

    # 1) Sweep τ
    ensure_dir(SWEEP_DIR)

    print("\n[SWEEP] DEV")
    taus, abst_dev, cov_dev = sweep_tau(dev_cards, "DEV", SWEEP_DIR)

    print("\n[SWEEP] H")
    _, abst_h, cov_h = sweep_tau(h_cards, "H", SWEEP_DIR)

    # 2) Choix τ* (sur DEV, cible d'abstention)
    best_idx = min(range(len(taus)), key=lambda i: abs(abst_dev[i] - TARGET_ABST))
    tau_star = taus[best_idx]
    thr = 1.0 - tau_star

    print(f"\n[CAL] target_abst={TARGET_ABST:.2f} -> τ*={tau_star:.4f} (thr={thr:.4f})")

    # 3) Run protocole avec τ*
    print("\n== DEV ==")
    run_protocol(dev_cards, tau_star, OUT_DEV)

    print("\n== HOLDOUT-H ==")
    run_protocol(h_cards, tau_star, OUT_H)

if __name__ == "__main__":
    main()