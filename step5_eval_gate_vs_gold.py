# -*- coding: utf-8 -*-
"""step5_eval_gate_vs_gold

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15ZSD-IHirkzs8h6IwF07NzqWNaGz0Jx9
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Étape 5 — Évaluation de la PORTE (gating-only) vs GOLD — BMO

- Joint : eligibility_audit.csv (accept/abstain) × gold_labels.csv
- Mesure :
    * abstention_rate_all  (sur tous les tickets)
    * coverage_on_labeled  (part des tickets *labellisés* que la porte accepte)
    * coverage_per_label   (même chose, par type d'incident)
- Sorties :
    * protocol_bmo_eval_DEV/metrics_gate.json + figures
    * protocol_bmo_eval_H/metrics_gate.json   + figures
"""

import os, csv, json

# ========= CHEMINS À VÉRIFIER (BMO) =========
GOLD    = "/content/drive/MyDrive/gold/gold_labels.csv"
AUD_DEV = "/content/drive/MyDrive/protocol_bmo_dev/eligibility_audit.csv"
AUD_H   = "/content/drive/MyDrive/protocol_bmo_H/eligibility_audit.csv"

OUT_DEV = "/content/drive/MyDrive/protocol_bmo_eval_DEV"
OUT_H   = "/content/drive/MyDrive/protocol_bmo_eval_H"
# ===========================================

# Les incidents qu'on considère (doivent correspondre aux labels GOLD)
I_IDS = {
    "i:release_regression",
    "i:infra_instability",
    "i:security_threat",
    "i:minor_degradation",
    "i:insufficient_info",
    "i:false_positive",
    "i:business_side_effect",
}

def ensure_dir(p: str):
    os.makedirs(p, exist_ok=True)

def load_gold_map(path: str):
    """
    Charge gold_labels.csv -> dict episode_id -> gold_label
    et ajoute les variantes BUGS-12345 / 12345 pour être robuste.
    """
    m = {}
    with open(path, newline="", encoding="utf-8") as f:
        rdr = csv.DictReader(f)
        for r in rdr:
            eid = str(r.get("episode_id", "")).strip()
            lab = str(r.get("gold_label", "")).strip()
            if not eid or lab not in I_IDS:
                continue
            m[eid] = lab
            # mapping BUGS-12345 <-> 12345
            if eid.startswith("BUGS-"):
                num = eid.split("-", 1)[1]
                m[num] = lab
            else:
                m[f"BUGS-{eid}"] = lab
    return m

def eval_gate(audit_csv: str, gold_map: dict, out_dir: str):
    """
    Lit eligibility_audit.csv et joint avec gold_map.
    Calcule métriques + figures simples.
    """
    ensure_dir(out_dir)
    rows = []
    with open(audit_csv, newline="", encoding="utf-8") as f:
        rdr = csv.DictReader(f)
        for r in rdr:
            eid = r["episode_id"]
            p   = float(r["p_top"])
            acc = (r["accepted"] in {"1", "True", "true", "TRUE"})
            lab = gold_map.get(eid)
            rows.append((eid, p, acc, lab))

    n_all = len(rows)
    labeled = [(eid, p, acc, lab) for (eid, p, acc, lab) in rows if lab is not None]
    n_lab = len(labeled)
    covered = [(eid, p, acc, lab) for (eid, p, acc, lab) in labeled if acc]
    n_cov = len(covered)

    # taux d’abstention global (sur tous les tickets de la split)
    abst_all = 1.0 - (sum(1 for (_, _, acc, _) in rows if acc) / n_all) if n_all else 0.0
    # parmi les tickets avec étiquette GOLD, combien sont passés à travers la porte ?
    coverage_on_labeled = (n_cov / n_lab) if n_lab else 0.0

    # couverture par type d’incident (GOLD)
    per_label_tot = {lab: 0 for lab in I_IDS}
    per_label_cov = {lab: 0 for lab in I_IDS}
    for (_, _, acc, lab) in labeled:
        per_label_tot[lab] += 1
        if acc:
            per_label_cov[lab] += 1
    coverage_per_label = {
        lab: (per_label_cov[lab] / per_label_tot[lab]) if per_label_tot[lab] > 0 else 0.0
        for lab in I_IDS
    }

    metrics = {
        "episodes_all": n_all,
        "accepted_all": sum(1 for (_, _, acc, _) in rows if acc),
        "abstention_rate_all": round(abst_all, 4),
        "episodes_labeled": n_lab,
        "covered_non_abstain": n_cov,
        "coverage_on_labeled": round(coverage_on_labeled, 4),
        "coverage_per_label": {k: round(v, 4) for k, v in coverage_per_label.items()},
    }

    # Sauvegarde JSON
    with open(os.path.join(out_dir, "metrics_gate.json"), "w", encoding="utf-8") as fw:
        json.dump(metrics, fw, ensure_ascii=False, indent=2)

    # Figures simples (matplotlib sans style particulier)
    try:
        import matplotlib
        matplotlib.use("Agg")
        import matplotlib.pyplot as plt

        # 1) barre couverture
        plt.figure(figsize=(5, 4))
        plt.bar(["labeled", "covered_non_abstain"], [n_lab, n_cov])
        plt.title("Gate coverage")
        plt.tight_layout()
        plt.savefig(os.path.join(out_dir, "fig_gate_coverage.png"), dpi=160)
        plt.close()

        # 2) distribution p_top sur les couverts
        pts = [p for (_, p, acc, lab) in covered]
        plt.figure(figsize=(8, 4.5))
        if pts:
            plt.hist(pts, bins=30)
        plt.xlabel("p_top (covered & non-abstain)")
        plt.ylabel("count")
        plt.title("p_top on covered tickets")
        plt.tight_layout()
        plt.savefig(os.path.join(out_dir, "fig_p_top_on_covered.png"), dpi=160)
        plt.close()
    except Exception as e:
        print("[FIG][WARN]", e)

    print(f"[EVAL] {out_dir} -> {metrics}")

def main():
    gold = load_gold_map(GOLD)
    print(f"[INFO] GOLD chargés : {len(gold)} épisodes")

    # DEV
    eval_gate(AUD_DEV, gold, OUT_DEV)

    # HOLDOUT-H
    eval_gate(AUD_H, gold, OUT_H)

if __name__ == "__main__":
    main()